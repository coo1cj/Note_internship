### Note WEEK3

#### 智能指针

##### 为什么要有智能指针，相比原生指针的优点在哪？   A： 相比原生指针智能指针能够在指针离开作用域时自动释放指针所指资源的内存，防止内存泄漏，请看以下例子 

```
class A{
  ....
}

void f(){
  A* p = new A();
  ....
  if(...)
    throw exception;
  delete p;
  p = nullptr;
}

```

##### 从上面的例子中可以发现，当函数f执行抛出异常时，函数会直接返回导致后面的delete没有释放掉p所指的资源，造成资源泄漏。 当然这只是一个例子，所有的所有，智能指针的出现只是为了防止因程序员的操作不当而造成的内存泄漏。


##### - auto_ptr: 自C++11起被移除，是C++11之前的替代品，auto_ptr有拷贝语义，拷贝后源对象变得无效（但因此会变得危险，因为后面如果再使用被拷贝的指针就会导致程序崩溃）。std::auto_ptr不能用于数组（转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的）

##### - unique_ptr：C++11之后的产物，只有唯一的所有权，也就是说不能有多个unique_ptr指向同一个对象，和auto_ptr一样但unique_ptr比auto_ptr更安全，因为它禁止了拷贝复制和拷贝赋值操作。但允许移动复制，如下

```
unique_ptr<A> F(){
  ...
  return unique_ptr<A>;
}

unique_ptr<A> a = F();
```
##### 在这个例子中是可行的，因为F（）的返回值是一个临时对象也就是一个右值，这样就发生了移动赋值。


##### - shared_ptr： 以引用计数的方式进行赋值，每有一个智能指针share_ptr指向一个对象，则计数+1，每一个智能指针失去所有权就-1，到计数超过一定限制或者变为0时，所指对象被释放。

##### - weak_ptr： 好像是指向对象时不会产生引用计数，也就是不会加1，在循环引用share_ptr时可以解决这个问题
