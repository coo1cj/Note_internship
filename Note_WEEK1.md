#### *动态链接库和静态链接库的区别*： 静态链接库在生成可执行文件时是和汇编生成的目标文件.o直接打包在一起的，静态库对函数库的链接是而动态链接库是在程序运行时调用的。相比静态库，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题，并且每次更新时程序不需要重新编译链接，做到实时更新。而静态链接库再更新之后需要将程序和库重新编译链接在一起。

#### *Overloading*: 指的是在同一scope下相同名字的函数，但是函数标签不同
#### *Overriding*: 指的是在继承中的重写，函数名称和标签相同，是派生类对基类函数的重写以实现多态。 存在于两个不同的scope

### 源文件的编译过程： 预编译 -> 编译 -> 汇编 -> 链接

- #### *预编译*： 处理各种宏，展开```#include``` 包含的头文件等，以及删除注释， 条件编译 即```#ifndef #define #endif``` 之类的， 防止头文件被多次重复引用

- #### *编译*： 将代码转换成汇编码，①编译器在每个文件中保存一个函数地址符表，该表中存储着当前文件内包含的各个函数的地址； ② 因为这步要生成汇编代码，即一条一条的指令，而调用函数的代码会被编译成一条call指令，call指令后面跟的是jmp指令的汇编代码地址，而jmp指令后面跟的才是“被调用的函数编译成汇编代码后的第一条指令”的地址，但是给call指令后面补充上地址的工作是在链接的时候做的事情

- #### *汇编*： 将汇编码变成机器码

- #### *链接*： 将多个.obj目标文件链接起来生成.exe执行文件（就是将二进制码和相关的库链接绑定起来）。 但是在这个过程中，编译器做的一个重要的事情是将每个文件中call指令后面的地址补充上；方式是从当前文件的函数地址符表中开始找，如果没有，继续向别的文件的函数地址符表中找，找到后填补在call指令后面，如果找不到，则链接失败。



#### 关于const的一些理解：
#### - 当出现在函数参数中时： 一般来说对于内部数据类型在传参时不需要用const的引用传递，因为内部数据值传递的临时对象的拷贝复制效率和引用传递差不多。（但之前看过有视频中说最好都用引用传递，因为引用传递其实就是指针,在32位机器上都是传4个字节，比double什么的会快一点，但影响不大）。 最重要的是当发生值传递的时候*不需要*加const，因为本来就是有个临时变量在函数内，不会影响的传参的那个变量。

#### - 当出现在修饰函数的返回值时： 表示这个返回值的内容不能被修改，并且接受返回值的类型必须是const同类型。 如果函数返回值采用“值传递方式”，由于函数会把返回值*复制到外部临时的存储单元中*，加const 修饰*没有任何价值*

#### - 用在成员函数上时： 表示在这个函数不会修改数据成员，加了const如果在函数内修改了数据成员就会报错。 const 函数只能调用 const 函数，即使某个函数本质上没有修改任何数据，但没有声明为const，也是不能被const函数调用的。

```
class my {  
 public:  
// ...  
 string& operator[](const string& s) const  
 { return table[s]; }  
private:  
 map table;  
}; 
```

#### 上面是不能通过编译的，因为这个函数是const但是table[s]这个map取下标函数并不是const。
