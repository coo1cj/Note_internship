#### *动态链接库和静态链接库的区别*： 静态链接库在生成可执行文件时是和汇编生成的目标文件.o直接打包在一起的，静态库对函数库的链接是而动态链接库是在程序运行时调用的。相比静态库，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题，并且每次更新时程序不需要重新编译链接，做到实时更新。而静态链接库再更新之后需要将程序和库重新编译链接在一起。

#### *Overloading*: 指的是在同一scope下相同名字的函数，但是函数标签不同
#### *Overriding*: 指的是在继承中的重写，函数名称和标签相同，是派生类对基类函数的重写以实现多态。 存在于两个不同的scope

### 源文件的编译过程： 预编译 -> 编译 -> 汇编 -> 链接

- #### *预编译*： 处理各种宏，展开```#include``` 包含的头文件等，以及删除注释， 条件编译 即```#ifndef #define #endif``` 之类的， 防止头文件被多次重复引用

- #### *编译*： 将代码转换成汇编码，①编译器在每个文件中保存一个函数地址符表，该表中存储着当前文件内包含的各个函数的地址； ② 因为这步要生成汇编代码，即一条一条的指令，而调用函数的代码会被编译成一条call指令，call指令后面跟的是jmp指令的汇编代码地址，而jmp指令后面跟的才是“被调用的函数编译成汇编代码后的第一条指令”的地址，但是给call指令后面补充上地址的工作是在链接的时候做的事情

- #### *汇编*： 将汇编码变成机器码

- #### *链接*： 将多个.obj目标文件链接起来生成.exe执行文件（就是将二进制码和相关的库链接绑定起来）。 但是在这个过程中，编译器做的一个重要的事情是将每个文件中call指令后面的地址补充上；方式是从当前文件的函数地址符表中开始找，如果没有，继续向别的文件的函数地址符表中找，找到后填补在call指令后面，如果找不到，则链接失败。
