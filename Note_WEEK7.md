### Note_WEEK7

在指针中 
```
int i = 0;
const int *p = &i;   //p指向的是常量，也就是不能通过*p改变i的值
int *const q = &i;   //q是常量指针，也就是说q不能再指向其他地址
```
其中第二行的指针是底层const，表示指针所指的对象是一个常量，而第三行的指针是顶层const，表示指针本身是个常量。

还有就是对于常量来说一定要初始化，为什么，因为常量可以看出是只读变量，所以，之后是不能在赋值的，因此需要初始化。常量指针也一样必须初始化。

摘自CSDN：
顶层 const 与底层 const 概念

指针本身是一个对象，因为，指针实际对应着内存单元的一段存储空间，然而，指针所指向的也是一个数据对象，因此，指针是一个常量与指针所指向的是一个常量是两个完全不同的概念， 顶层 const 表示的是 指针本身是一个常量， 底层 const 表示的是 指针所指的对象是一个常量，更一般情况下， 顶层 const 可以表示任意对象是一个常量，这对于算术类型、类、指针等任何数据类型都是成立的， 底层 const 则与指针和引用等复合类型的基本类型部分有关 ，比较特殊的是，指针既可以是顶层 const 也可以是底层 const ，这一点与其他类型区别明显。

#### 对于顶层 const 与底层 const ，在执行对象拷贝时有着明显的不同：

（1）顶层 const 不受什么影响
```
int i = 0;  
const int ci = 42;   // 不能改变 ci 的值，这是一个顶层 const  
i = ci;   // 正确：ci 是一个顶层 const，对此操作无影响  
const int *p2 = &ci;  // 允许改变 p2 的值，这是一个底层 const  
const int *const p3 = p2;  // 靠右的 const 是顶层 const ，靠左的是底层 const  
p2 = p3;   // 正确：p2 和 p3 指向的对象的类型相同，p3 顶层 const 的部分不影响  
```

（2）底层 const 的限制不能忽略，  要求拷出和拷入的对象有相同的底层 const 资格或者能转换为相同的数据类型，一般非常量能够向常量转换，反之则不行
```
int *p = p3;  // 错误：p3 包括底层 const 定义，而 p 没有  
p2 = p3;   // 正确：p2 和 p3 都是底层 const  
p2 = &i;   // 正确：int* 能转换成 const int*  
int &r = ci;  // 错误：普通的 int& 不能绑定到 int 常量上  
const int &r2 = i;  // 正确：const int& 可以绑定到一个普通 int 上  
```

来分析一下以上的代码：

```int *p = p3;```
#### p3 既是一个顶层 const 又是一个底层 const，在执行对象拷贝时，顶层 const 部分没有任何影响，完全不用考虑，但是 p3 又是一个底层 const ，它要求拷入的对象有相同的底层 const 资格，而 p 没有，所以是错的；

```p2 = p3;```
#### p3 要求拷入的对象拥有相同的底层 const 资格，p2 也是一个底层 const，故正确；

```p2 = &i;```
#### 对 i 取地址将得到 int*， p2 是 const int*，前者是非常量，后者是常量，赋值语句等号右侧的类型向左侧转换，非常量能够向常量转换，故正确；

```int &r = ci;```
#### 由左侧部分我们知道，需要得到的是一个绑定到 ci 上的引用，而绑定到 ci 上的引用的类型是 const int&，等号左侧的类型是 int&，赋值语句等号右侧的类型向左侧转换，但是常量不能向非常量转换，所以是错误的；

```const int &r2 = i;```
#### 由左侧部分我们知道，需要得到的是一个绑定到 i 上的引用，而绑定到 i 上的引用的类型是 int&，等号左侧的类型是 const int&，赋值语句等号右侧的类型向左侧转换，一般非常量可以向非常量转换，所以是正确的。

不仅要注意类型转换的限制 同时需要考虑const的性质



还要说俩类型声明一个是 auto 一个是decltype
- auto: 类型会自动通过初始值判断

- decltype: 类型通过某个变量类型或者表达式类型判断  如```int d; decltype((d)) e;``` 中 e的类型就是int&， 而```decltype(d)```的类型就是int。 然而``` int *p = &i; decltype(*p) e```中e是int&类型，为什么？ 因为解引用指针可以指向指针所指的对象，还能给这个对象赋值，这就是引用类型的特点（指向一个对象，并可以操作对象）

### ！切记：当decltype((variable))时， 有双括号时它的结果永远是引用类型，而decltype(variable)只有当variable的类型是引用时才会是引用类型 

对于函数的返回值问题，一直在思考这个问题。除了返回值是引用类型之外，其他返回值在编译器无优化的情况下都是先把返回值的数据拷贝给一个临时对象，然后这个临时对象再拷贝给main函数中接收返回值的对象。 相当于拷贝了两次，而编译器优化之后就不会有临时对象，直接将返回值拷贝给接收对象。


对于栈堆的一些理解[参考](https://www.cnblogs.com/carsonzhu/p/12612417.html)

### RAII
Resource Acquisition Is Initialization，RAII 依托栈和析构函数，来对所有的资源包括堆内存在内进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：
- 关闭文件（`fstream` 的析构就会这么做）
- 释放同步锁（std::lock_guard<std::mutex> guard(mtx)）
- 释放其他重要的系统资源


